package equus.carbine.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

import com.google.common.base.Preconditions;

import equus.carbine.exception.NoSuchMethodRuntimeException;

public final class TestUtils {

    /**
     * The basis time (ms) for performance test.<br>
     * This is about 100(ms) in my environment.
     */
    public static final double BASIS_TIME = getBasisTime();

    private static final Runtime RUNTIME = Runtime.getRuntime();

    /**
     * Returns the time(ms) around running.
     * 
     * @param runnable runnable
     * @return the time(ms) around running.
     */
    public static double getMilliTime(Runnable runnable) {
        return getMilliTime(runnable, 1);
    }

    /**
     * Returns the time(ms) around running.
     * 
     * @param runnable runnable
     * @param loop loop count
     * @return the time(ms) around running.
     */
    public static double getMilliTime(Runnable runnable, long loop) {
        long startTime = System.nanoTime();
        for (long i = 0; i < loop; i++) {
            runnable.run();
        }
        return ((double) System.nanoTime() - startTime) / 1000000;
    }

    private static double getBasisTime() {
        long loop = 200000000;
        double time = getMilliTime(new Runnable() {

            @Override
            public void run() {
                Integer.valueOf(1 + 1);
            }
        }, loop);
        System.out.println("basis time is " + time + "(ms)");
        return time;
    }

    /**
     * Gets used memory size.<br>
     * Maybe returns inaccurate size due to GC.
     * 
     * @return used memory size
     */
    public static long getUsedMemory() {
        long usedMem1 = 0;
        long usedMem2 = Long.MAX_VALUE;
        for (int r = 0; usedMem1 != usedMem2 && r < 20; r++) {
            usedMem1 = usedMem2;
            long result1 = Long.MAX_VALUE;
            long result2 = Long.MAX_VALUE;
            for (int i = 0; i < 10; ++i) {
                RUNTIME.runFinalization();
                RUNTIME.gc();
                Thread.currentThread();
                Thread.yield();

                result2 = RUNTIME.totalMemory() - RUNTIME.freeMemory();
                if (result2 < result1) {
                    result1 = result2;
                }
            }
            usedMem2 = result1;
        }
        return usedMem1;
    }

    /**
     * Gets the size of object generated by {@link Generator#generate()}.<br>
     * Measuring used memory size difference, maybe returns inaccurate size due to GC or caching.
     * 
     * @param generator generator
     * @return Object Size
     */
    public static long getObjectSize(Generator generator) {
        generator.generate(); // for class load.
        long heapBefore = getUsedMemory();
        Object obj = generator.generate();
        long heapAfter = getUsedMemory();
        long size = heapAfter - heapBefore;
        if (0 <= size) {
            System.out.println("{" + obj.getClass() + "} size = " + size + " bytes");
            return size;
        } else {
            // if size is minus, try once more.
            return getObjectSize(generator);
        }
    }

    public interface Generator {

        /**
         * Generate.
         * 
         * @return the object
         */
        Object generate();
    }

    /**
     * Get private method invoker.
     * 
     * @param <T> target object type
     * @param object target object
     * @param name method name
     * @param parameterTypes parameterTypes
     * @return method invoker
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public static <T> MethodInvoker<T> privateMethod(T object, String name, Class... parameterTypes) {
        Preconditions.checkNotNull(object, name);
        Class cls = object.getClass();
        while (cls != null) {
            try {
                Method method = cls.getDeclaredMethod(name, parameterTypes);
                method.setAccessible(true);
                return new MethodInvoker<T>(object, method);
            } catch (Exception ex) {
            }
            cls = cls.getSuperclass();
        }
        throw new NoSuchMethodRuntimeException("Failed method invocation: " + object.getClass().getName() + "." + name
                        + "()");
    }

    /**
     * MethodInvoker
     * 
     * @param <T> target object type
     */
    public static final class MethodInvoker<T> {

        private final T object;

        private final Method method;

        private MethodInvoker(T object, Method method) {
            this.object = object;
            this.method = method;
        }

        /**
         * Invoke method.
         * 
         * @param args args
         * @return return value
         */
        public Object invoke(Object... args) {
            try {
                return method.invoke(object, args);
            } catch (Exception e) {
                throw new NoSuchMethodRuntimeException(e);
            }
        }
    }

    /**
     * Get private method invoker.
     * 
     * @param <T> target class type
     * @param clazz target class
     * @param parameterTypes parameterTypes
     * @return method invoker
     */
    @SuppressWarnings("rawtypes")
    public static <T> ConstractorInvoker<T> privateConstractor(Class<T> clazz, Class... parameterTypes) {
        Preconditions.checkNotNull(clazz);
        Constructor<T> constructor;
        try {
            constructor = clazz.getDeclaredConstructor(parameterTypes);
        } catch (Exception e) {
            throw new NoSuchMethodRuntimeException(e);
        }
        constructor.setAccessible(true);
        return new ConstractorInvoker<T>(constructor);
    }

    /**
     * ConstractorInvoker
     * 
     * @param <T> target object type
     */
    public static final class ConstractorInvoker<T> {

        private final Constructor<T> constructor;

        private ConstractorInvoker(Constructor<T> constructor) {
            this.constructor = constructor;
        }

        /**
         * Invoke method.
         * 
         * @param args args
         * @return return value
         */
        public Object newInstance(Object... args) {
            try {
                return constructor.newInstance(args);
            } catch (Exception e) {
                throw new NoSuchMethodRuntimeException(e);
            }
        }
    }
}
